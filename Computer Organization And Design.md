## 1. Computer Abstractions and Technology

### 1.1 介紹

#### 計算應用的種類與它們的特性

- 個人型計算機
  - 最為人熟知的計算型式
  - 強調以低成本提供單一使用者不錯的效能
  - 能執行其他公司的軟體
- 伺服器
  - 大型主機、迷你計算機及超級電腦的現代版
  - 通常經由網路來使用
  - 伺服器強調其可靠度，其當機的代價通常高於單一使用者的個人電腦
- 嵌入式計算機
  - 計算機中最大的一個族群
  - 在應用與效能的範圍也最廣
  - 嵌入式計算系統是設計來執行單一應用或一組相關的應用
  - 嵌入式應用通常有其獨特的應用需求以及最低效能和嚴格的成本與與功耗限制

### 1.2 計算機架構的八大理念

- 配合摩爾定律作設計
  - 該定律指出IC容量於每18至24年即加倍
- 用抽象化來簡化設計
  - 計算機架構師與程式師均需想出使自己更有產能的方法，否則其花費在設計上的時間將有如資源量隨摩爾定律而膨脹般遽增。
  - 使用抽象化，可提供一個簡潔的模型予上方各層
- 使經常的情形變快
  - 經常的情形往往也比較少見者為單純且易於改良
  - 需透過仔細的實驗與測量以求確保

- 經由平行性提升效能
- 經由管道處理提升效能
- 經由預測提升效能
  - 在一些情況下假設你的預測已經夠準確並且由錯誤的預測中回復的機制不會太昂貴的話，平均而言猜測結果後就劇以開始繼續作下去會比等到確之結果才更快。
- 記憶體的階層
  - 程式設計師希望記憶體要容量大，速度快且低廉
  - 記憶體的速度會影響效能、容量又限制可以處理問題的規模、而且目前計算機價格的主要部份來自於記憶體的成本。
  - 可以用階層式的不同記憶體來滿足這些互相牴觸的要求，其方式是將最快最小和每位元單價最貴的記憶體至於頂層，而最慢最大和每位元單價最廉價的記憶體置於底層。
- 經由冗餘提升可靠性
  - 計算機不只快，還要可靠。
  - 物理裝置難免失效，於是我們以加入額外組件以便失效發生時接手及幫助檢出失效情況的方式使系統成為可靠。

### 1.3 你的程式之下

- 每一個計算機中最重要的有兩類：作業系統與編譯器
- 作業系統將使用者應用與硬體關聯上，並提供各種服務與管控的功能
  - 處理基本輸出入的動作
  - 配置儲存體與記憶體
  - 在多個應用同時使用計算機時提供有保護的分享
- 編譯器執行另一重要功能：將高階語言如C、C++、Java或Visual Basic所寫的程式翻譯成硬體可執行的一群指令。
- 程式將一道以符號表示的組合語言翻譯成二進形式的機器語言，稱為組譯器。

- 程式師應將他們的生產力，以及他們可以更清楚思考，歸功於高階程式語言以及可以將以其編撰的程式翻譯成組合指令的編譯器。
- 高階程式語言的好處
  - 他們使用英語文字與算術表示法，容許程式師以更自然的語言思考，也使得程式看起來更像文字而非晦澀難懂的符號表
  - 更好的程式師產生力，軟體開發領域裡少有的共識之一，就是當程式開發時如果能採用可以用更少行來表達一個思想的語言，則所需時間較少
  - 程式不須與開發他們時所使用的計算機相關，此乃因為編譯器與組譯器可將高階語言程式翻譯成任何計算機的二進指令。

### 1.4 覆蓋之下

- 所有計算機內的硬體都執行以下的基本功能：輸入資料、輸出資料、處理資料以及儲存資料。
- 計算機的兩種關鍵組件是輸入裝置以及輸出裝置
- 有些裝置比如無線網路可同時提供計算機輸入與輸出
- 存資料的安全地方
  - 計算機內的記憶體是揮發性記憶體，一旦失去電力就會忘記
  - 光碟並不因你切斷電力而失去所記錄的影片，因此其為一種非揮發性記憶體
  - 我們以名詞主記憶體來代表保存正在執行中的數據及程式的揮發性記憶體
  - 我們以名詞次記憶體來代表保存執行之間的數據及程式的非揮發性記憶體
- 有網路的電腦的優勢
  - 通訊：資訊可在計算機間以高速交換
  - 資源分享：與其每個計算機擁有自己的輸入/輸出裝置，同一網路上的計算機可共享之
  - 非本地存取：連結遠距離的計算機，使用者即可使用遠方的計算機

## 1.5 建構處理器與記憶體的技術

### 1.5.1 科技趨勢

- 電子產品逐漸發展中
- 追求效能增加與價格減少
- 效能與價格比越來越高

| 年代 | 一些科技     | 效能與價格比 |
| ---- | ------------ | ------------ |
| 1951 | 真空管       | 1            |
| 1965 | 電晶體       | 35           |
| 1975 | 積體電路     | 900          |
| 1995 | 超大積體電路 | 2400000      |
| 2013 | 極大積體電路 | 250000000000 |

### 1.5.2 半導體科技

- 半導體由矽組成
- 加上導體、絕緣體、開關改變他的性質

### 1.5.3 積體電路的製造

![img](https://i.imgur.com/cs7XQUM.jpg)

- 良率：一個晶元上好晶粒占所有晶粒數量的百分率。

### 1.5.4 良率

$\text{Cost per die} = \dfrac{\text{Cost per wafer}}{\text{Dies per wafer} \times \text{Yield}}$

$\text{Dies per wafer} \approx \dfrac{\text{Wafer area}}{\text{Die area}}$

$\text{Yield} = \dfrac{1}{(1+(\text{Defects per area} \times \text{Die Area}/2))^2}$

面積與不良率的非線性關係

- 晶圓圓片價格與面積是固定的
- 不良率取決在於製造的流程
- 晶片損毀區域大小取決於架構與電路設計



## 1.6 效能

### 1.6.1 回應時間與流通量

回應時間：要花多少時間能夠完成工作

流通量：在一個時間單位內，總共能夠完成多少工作

### 1.6.2 時間

定義時間：

- 完成一個工作總共需要多少時間，包含硬碟與記憶體存取，輸入輸出的動作，OS...
- 可能包含其他程式在多執行緒的執行時間
- 包含很多因素

CPU的時間：

- 被稱作「CPU的執行時間」或者「CPU的時間」
- 通常還會細分成「對於OS的CPU時間」與「對於使用者程式的CPU時間」

CPU的表現：對於一個單一的程式，使用者的CPU時間。

### 1.6.3 相關表現

定義表現：$\text{Perfomance} = \dfrac{1}{\text{Execution Time}}$

若我們說$x$比$y$快$n$倍，則

$n = \dfrac{\text{Perfomance }p_x}{\text{Perfomance }p_y} = \dfrac{\text{Execution time }e_y}{\text{Execution time }e_x}$

要精確的確定一個程式的執行時間不是一件簡單的事情

我們通常都是「預估」一個程式的執行時間

### 1.6.4 CPU的時脈

![image-20210304164426097](https://i.imgur.com/0Q8M0m5.png)

時脈週期：一個時間週期的時間，例如$250\text{ps} = 2.5 \times 10^{-10}\text{s}$

時鐘頻率：一秒鐘的時脈次數，例如$4.0\text{GHz} = 4000\text{MHz} = 4\times 10^9\text{Hz}$

$\text{CPU}$時間：$\text{CPU Clock Cycles} \times \text{Clock Cycles Time} = \dfrac{\text{CPU Clock Cycles}}{\text{Clock Rates}}$

表現會隨著「減少一個時脈週期的時間」、「增加時鐘頻率」進步

通常來說，設計硬體的人會在這兩者之間衡量取決。



##### Example

Computer A: 2GHz clock, 10s CPU Time

設計一個電腦B，目標是6s CPU Time，且clock cycle增加1.2倍

$\text{Clock Rate}_B = \dfrac{\text{Clock Cycles}_B}{\text{CPU Time}_B} = \dfrac{1.2\text{Clock Cycles}_A}{6s}$

$\text{Clock Cycles}_A = \text{CPU Times}_A \times \text{Clock Rates}_A = 10s \times 2\text{GHz} = 20\times 10^9$

$\text{Clock Rate}_B = \dfrac{\text{Clock Cycles}_B}{\text{CPU Time}_B} = \dfrac{1.2\times20\times 10^9}{6s} = 4\text{GHz}$

### 1.6.5 指令執行時間

時間單位：依照使用者的看法，通常來說是秒。

CPU時間：電腦利用固定頻率的時脈來執行指令，並且決定事件發生的時間。

執行時間以cycle為單位。

### 1.6.6 程式執行時間

CPU的執行程式的時間：$\text{Clock Cycle for program} \times \text{Clock Cycle Time} = \dfrac{\text{Clock Cycles for Program}}{\text{Clock Rate}}$

CPI：Clock cycles per Instruction，也就是一個指令所需的時脈週期

對於程式的CPU的時脈週期：程式的指令數 x CPI

### 1.6.7 指令數量與CPI

$\text{Clock Cycles} = \text{Instruction Count} \times \text{Cycles per Instruction}$

$\text{CPU Time} = \text{Instruction Count} \times \text{CPI} \times \text{Clock Cycles Time} = \dfrac{\text{Instruction Count} \times \text{CPI}}{\text{Clock Rates}}$

決定程式指令數量的要素：決定於程式、指令集架構與編譯器

平均一個指令的時脈週期：決定於CPU，也被不同種類的指令所影響

##### Example

A電腦：$\text{Cycle Time = 250ps}, \text{CPI = 2.0}$

B電腦：$\text{Cycle Time = 500ps, CPI = 1.2}$

一樣的指令集架構，哪一個比較快速，然後大概需要多少時間？

在A電腦，一個指令通常需要執行$250 \times 2.0 = 500\text{ps}$

在B電腦，一個指令通常需要執行$500 \times 1.2 = 600\text{ps}$

故A電腦比B電腦快。

A電腦比B電腦快$\dfrac{600}{500} = 1.2$倍

### 1.6.8 更多關於CPI的部分

不同的指令類別，使用不同數量的時脈

$\displaystyle \text{Clock Cycles} = \sum_{i = 1}^{n}(CPI_i \times IC_i)$

計算加權平均的CPI

$\text{CPI} = \dfrac{\text{Clock Cycles}}{\text{Instruction Count}} = \displaystyle \sum^{n}_{i=1}(CPI_i \times \dfrac{\text{Instruction Count}_i}{\text{Instruction Count}})$

##### Example

![image-20210304174219987](https://i.imgur.com/AMxkwxZ.png)

若Sequence 1的$IC = 5$，則$\text{Clock Cycles} = 2\times 1 + 2\times 1 + 3\times 2 = 10$

所以$\text{Avg. CPI} = \dfrac{10}{5} = 2$

若Sequence 2的$IC = 6$，則$\text{Clock Cycles} = 4\times 1 + 1\times 2 + 1\times 3 = 9$

所以$\text{Avg. CPI} = \dfrac{9}{6} = 1.5$

### 1.6.9 對於CPU表現的總結

$\text{CPU Times} = \dfrac{\text{Instruction}}{\text{Program}} \times \dfrac{\text{Clock Cycles}}{\text{Instruction}}\times \dfrac{\text{Seconds}}{\text{Clock Cycles}}$

表現通常依賴於：

1. 演算法(影響指令數量與可能影響CPI)
2. 程式語言(影響IC與CPI)
3. 編譯器(影響IC與CPI)
4. 指令集架構(影響IC與CPI以及時脈)



## 1.7 功耗壁障

- 對於CMOS，能耗可以這樣表示：

  - $\text{Energy} \propto \dfrac{1}{2} \times \text{Capacitive load} \times \text{Voltage}^2 \times \text{Clock Rate}$

    其中Energy是能量，Capacitive load是電容性負載，Voltage是電壓。Clock Rate是時脈。

- 降低電壓會使得電晶體漏電太多，有如水龍頭無法關緊，故降低電壓可以有效降低能量，但不適用於現代的方法。



## 2. Instructions: Language of the Computer

### 2.1 介紹

- 計算機語言中的單字稱為指令，而它的字彙稱為指令集。

#### 2.1.1 MIPS運算元

|        名稱        | 舉例                                                         | 註解                                                         |
| :----------------: | :----------------------------------------------------------- | ------------------------------------------------------------ |
|     32個暫存器     | ```$s0-$s7, $t0-$t9，$zero，$a0-$3，$v0-$v1，$gp，$fp，$sp，$ra，$at``` | 快速存取資料的地方。在MIPS中，資料必須要在暫存器裡才能執行運算，暫存器$zero恆等於0，而暫存器\$at則是保留給組譯器來處理值很大的常數。 |
| $2^{30}$記憶體字組 | ```Memory[0], Memory[4] ... Memory[4294967292]```            | 在MIPS裡，記憶體只能由資料傳輸指令來存取。MIPS使用位元組位址，所以連續的字組位置相差4。記憶體裡儲存資料結構，陣列和溢出暫存器(spilled register) |

#### 2.1.2 MIPS組合語言

| 指令           | 舉例                  | 意義                       | 註解                           |
| -------------- | --------------------- | -------------------------- | ------------------------------ |
| 加法           | ```add $s1,$s2,$s3``` | ```$s1=$s2+$s3```          | 三個暫存器運算元               |
| 減法           | ```sub $s1,$s2,$s3``` | ```$s1=$s2-$s3```          | 三個暫存器運算元               |
| 加立即值       | ```addi $s1,$s2,20``` | ```$s1=$s2+20```           | 加上常數                       |
| 載入字組       | ```lw $s1, 20($s2)``` | ```$s1=Memory[$s2+20]```   | 字組由記憶體載入至暫存器       |
| 儲存字組       | ```sw $s1, 20($s2)``` | ```Memory[$s2+20] = $s1``` | 字組由暫存器儲存至記憶體       |
| 載入半字組     | ```lh $s1, 20($s2)``` | ```$s1 = Memory[$s2+20]``` | 半字組由記憶體載入至暫存器     |
| 載入無號半字組 | ``lhu $s1, 20($s2)``  | ``$s1 = Memory[$s2+20]``   | 無號半字組由記憶體載入至暫存器 |
| 儲存半字組     | ``sh $s1,20($s2)``    | ```Memory[$s2+20] = $s1``` | 半字組由暫存器儲存至記憶體     |
| 載入位元組     | ```lb $s1,20($s)```   | ```$s1=Memory[$s2+20]```   | 位元組由記憶體載入至暫存器     |
| 載入無號位元組 | ```lbu $s1,20($s2)``` | ```$s1=Memory[$s2+20]```   | 無號位元組由記憶體載入至暫存器 |
| 儲存位元組     | ```sb $s1,20($s2)```  | ```Memory[$s2+20]=$s1```   | 位元組由暫存器儲存至記憶體     |
| 載入連結的字元組       | ```ll $s1,20($s2)``` | ```$s1=Memory[$s2+20]``` | 作為不可分割的（記憶體與儲存器內容）<br />交換中第一部分的載入字元組 |
| 條件式儲存字元組 | ```sc $s1,20($s2)``` | ```Memory[$s2+20]=$s1;$s1=0或1``` | 作為不可分割的（記憶體與儲存器內容）<br />交換中第二部分的載入字元組 |
| 載入上半部立即值 | ```lui $s1, 20``` | ```$s1=20*65536$``` | 載入常數至較高的16位元 |
| 及 | ```and $s1,$s2,$s3``` | ```$s1=$s2 & $s3``` | 三個暫存器運算元；逐位元的及運算 |
| 或 | ```or $s1,$s2,$s3``` | ```$s1=$s2 | $s3``` | 三個暫存器運算元；逐位元的或運算 |
| 反或 | ```nor $s1,$s2,$s3``` | ```$s1=~($s2 | $s3)``` | 三個暫存器運算元；逐位元的反或運算 |
| 及立即值 | ```andi $s1,s2,20``` | ```$s1 = s2 & 20``` | 暫存器與常數做逐位元的及運算 |
| 或立即值 | ```ori $s1,s2,20``` | ```$s1 = s2 & 20``` | 暫存器與常數做逐位元的或運算 |
| 邏輯左移 | ```sll $s1,s2,10``` | ```$s1 = $s2 << 10``` | 左移常數個位元位置 |
| 邏輯右移 | ```srl $s1,s2,10``` | ```$s1 = $s2 >> 10``` | 右移常數個位元位置 |
| 若等於則分支 | ```beq $s1,$s2,25``` | 若```($s1==$s2)```則前往```PC+4+100``` | 等於測試：PC相對的分支 |
| 若不等於則分支 | ```bne $s1,$s2,25``` | 若```($s1!=$s2)```則前往```PC+4+100``` | 不等於測試：PC相對的分支 |
| 若小於則分支 | ```slt $s1,$s2,25``` | 若```($s2<$s3)```，`$s1=1`;<br />否則`$s1=0` | 小於比較，用於beq, bne |
| 無號若小於則設定 | ```sltu $s1,$s2,$s3``` | 若```($s2<$s3)```，`$s1=1`;<br />否則`$s1=0` | 無號數的小於比較 |
| 若小於立即值則設定 | ```slti $s1,$s2,20``` | 若`($s2<20)`，`$s1=1`;<br />否則`$s1=0` | 小於某常數的比較 |
| 若無號小於立即值則設定 | ```sltiu $s1, $s2, 20``` | 若`($s2<20)`，`$s1=1`;<br />否則`$s1=0` | 無號數的小於某常數的比較 |
| 跳躍 | ```j 2500``` | 前往10000 | 跳至目的位置 |
| 透過暫存器跳躍 | ``jr $ra`` | 前往`$ra` | 用於switch敘述、程序返回 |
| 跳躍並連結 | ```jal 2500``` | ``$ra=PC+4 前往 10000`` | 用於程序呼叫 |



### 2.2 計算機硬體的運作

- 每一道MIPS算術指令只能執行一種運算且永遠一定使用三個變數。

- 若我們要相加四個變數a, b, c, d，則可以寫成以下

  ```
  add a, b, c
  add a, a, d
  ```

  

### 2.3 計算機硬體的運算元

- MIPS架構中暫存器的大小是32位元；一群群的32位元如此經常地被使用，因此它們也在MIPS架構中被稱為字組(word)。
- 很大數量的暫存器單純地由於其內部的電子訊號必須傳遞更遠而需時更久、可能導致時脈週期時間增加。



#### 2.3.1 記憶體運算元

- 程式語言具有內含單一數據元素的簡單變數，如以上各例所見；然而也有較複雜的資料結構─陣列(array)與結構(structurue)。

  該等複雜資料結構可包含較計算機中所具有的暫存器數目。

- MIPS指令的算術運算僅在暫存器上運作；因此MIPS也必須具有能在暫存器及記憶體間轉移資料的指令。

  該類地指令稱為資料轉移指令。

- 存取記憶體字組時，指令必須提供記憶體的位址。

- 記憶體是一個很大的一維陣列，並且由0開始的、稱為位置者作為其索引。

- 傳統上稱呼將記憶體中的值複製至暫存器中的資料轉移指令為載入。載入指令的格式包含運作名稱、後接將被載入值的暫存器、之後是用以存取記憶體的另一個常數以及另一個暫存器。

  記憶體位址由該常數加上第二個暫存器的內容而得。

- 實際的MIPS該指令稱為lw，代表載入字組(load word)



##### Example - 編譯有一個運算元在記憶體中的賦值敘述

假設A為含有100個字組的陣列，且編譯器已如前述將g與h存於`$s1`以及`$s2`中。另設陣列的開始位址，或稱基底位置，存於`$s3`中。

編譯下述C賦值敘述：

```c
g=h+A[8]
```



先把`A[8]`轉移至暫存器中：```lw $t0, 8($s3)```

再將其與`h`相加，存至`g`：```add $s1, $s2, $t0```



##### Example - 編譯使用到讀取與儲存的賦值敘述

假設變數h的值已被編譯器存至暫存器`$s2`，且base address陣列A已被編譯器存至暫存器`$s3`，求下列的C語言編譯後的MIPS組語敘述。

```c
A[12] = h + A[8]
```



```
ls $t0, 48($s3)   # 取得A[12]的值，並且放到暫存器
ls $t1, 32($s3)   # 取得A[8]的值，並且放到暫存器
add $t0, $s2, $t1 # h與A[8]做相加
sw $t0, 48($s3)   # 存回A[12]的記憶體中
```



#### 2.3.2 常數或immediate運算子

 - 程式很常在運算子中使用常數，例如增加index來讀取陣列的下一個元素。

   

##### Example - 用load word來做常數相加

假設`$s1 + AddrConstant4`是常數4的記憶體位址。

```
lw $t0, AddrConstant4($s1)  #$t0 = 常數4
add $s3, $s3, $t0           #$s3 = $s3 + $t0 = $s3 + 4
```



##### Example - 用add immdiate來做整數相加

我們可以用addi來直接做整數的相加，省略掉讀取或暫存的部分。

```
addi $s3, $s3, 4           #$s3 = $s3 + 4
```



### 2.4 有號數與無號數

與數位邏輯相同，MIPS中用的32位元數字，最左邊的數字代表有號或者無號，針對這個對二進制運算後轉成10進制。



### 2.5 指令呈現在電腦的方式

- 暫存器很常被指令所提及，因此我們可以透過指令的編號，來將指令表達成一連串的數字。



##### Example - 將MIPS組語翻譯成機器碼

將以下的MIPS組語翻譯成機器碼。

```
add $t0, $s1, $s2
```



我們可以翻譯成

|      0       |       17       |       18       |     8      |        0         |      32      |
| :----------: | :------------: | :------------: | :--------: | :--------------: | :----------: |
| MIPS指令形式 | 第一個指令元素 | 第二個指令元素 | 目標暫存器 | 沒有用到的指令格 | MIPS指令形式 |
|    000000    |     10001      |     10010      |   01000    |      00000       |    100000    |



#### 2.5.1 MIPS欄位

- MIPS欄位有各自的名子，方便我們去討論。



##### R-format

|         op         |       rs       |       rt       |     rd     |     shamt     | funct |
| :----------------: | :------------: | :------------: | :--------: | :-----------: | :---: |
| 這個指令的運算類別 | 第一個指令元素 | 第二個指令元素 | 目標暫存器 | 左移/右移數量 | 函數  |

##### I-format

|         op         |       rs       |       rt       | constant or address |
| :----------------: | :------------: | :------------: | :-----------------: |
| 這個指令的運算類別 | 第一個指令元素 | 第二個指令元素 | 常數或暫存器的地址  |



##### Example - 翻譯MIPS組語至機器語言

若base address陣列A存於暫存器`$t0`，變數h存於暫存器`$s2`中，且翻譯以下的C語言至機器語言。

```
A[300] = h + A[300];
```



首先我們要先把C語言轉成MIPS指令

```
lw $t1, 1200($t0)
add $t0, $t1, $s2
sw $t1, 1200($t0)
```



則接下來將其轉為R-format或者I-format

![img](https://i.imgur.com/U9OBVWu.png)

再將每一個欄位轉成二進制

![img](https://i.imgur.com/7Zsv1sK.png)